# 聚合类

## 聚合类的定义
1．没有用户提供的构造函数。

2．没有私有和受保护的非静态数据成员。

3．没有虚函数。

在新的扩展中，如果类存在继承关系，则额外满足以下条件。

4．必须是公开的基类，不能是私有或者受保护的基类。

5．必须是非虚继承。


## 设计聚合类的目的是什么?

**目的很简单，少写废话。**

C++很多功能不是设计出来，而是总结出来，比如这个**聚合类**。

最开始我们认为每个类都应该维护自己的不变式，都有自己的构造函数和析构函数。后来发现其实很多时候并不是这样，我们只是需要维护一个组合关系，比如数据库表中的字段。

聚合类是你自己不定义构造函数，由编译器生成使用花括号初始化列表的构造函数，以及其他的比如移动，拷贝等构造函数。不是编译器不准你定义，而是你交给编译器定义，不能弄反了。

有时你就是只想写一个数据类，用一下 `struct/class` 的包装作用，但是作为一个类又必须要有构造函数，而你要写的构造函数反正里面就是直接使用参数初始化对应的成员，属于跟默认构造函数一样完全可以交给编译器生成的。如果你写一个新的 `struct` 就要写一遍构造函数，写一遍初始化列表，写一遍拷贝构造，写一遍移动构造，写一遍赋值运算符······，而我只是实现想拿几个变量包一下取个名字这样简单的需求，也要写一堆无用代码，废话太多了，没有人想写一堆这种啰嗦的代码。

聚合初始化和参数是 `initializer_list` 参数的构造函数不是一回事，聚合初始化就是让你能花括号里按顺序填成员的值来初始化聚合类，这是一种特殊的语法。那你 `class a{"abc"，2}` 这样初始化，总不能说调用参数是一个存 `string` 和 `int` 的 `initializer_list` 的构造函数吧， `initializer_list` 成员还真的只能一个类型，因为它本来就一个模板参数，隐式转换那也是转换成同一个类型。

## 参考资料：

[现代C++新特性 扩展的聚合类型(C++17 C++20)](https://blog.csdn.net/qq_26405165/article/details/131628678)