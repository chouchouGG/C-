# 万能引用
***
## 万能引用的作用
如果采用右值来初始化万能引用，就会得到一个右值引用；如果采用左值来初始化，则会得到一个左值引用。

万能引用通常出现的两种场景：`函数模板的形参` 和 `auto声明`。
```C++
template<typename T> 
void f(T && param);   //param是万能引用

auto && var2 = var1; //var2是万能引用
```

即，如果遇到了**变量**或**参数类型**是 `T &&` 这样的形式，此时就有可能是万能引用（之所以是**有可能**是因为还需要满足两个条件）:

1. `T` 必须进行类型推导
2. 必须精确具有 `T &&` 形式


对于 1. ，如果类型推导并未发生，则 `T &&` 就代表右值引用，示例如下：
```C++
template <class T,class Allocator = allocator<T>>
class vector{
public:
    void push_back(T && x);
    ...
};
```
如 `vector` 中的 `push_back` 的形参 `x` ，虽然 `T` 是类型参数需要类型推导，但是推导并不是执行到 `push_back` 才进行，而是在 `vector` 实例化之初就已经确定，该 `vector` 实例就已经确定了 `push_back` 的参数类型。所以也可以说，万能引用的类型推导必须发生在当前语句之中。


对于 2. ，如果型别声明不精确地具备 `T &&` 的形式，则 `T &&` 就代表右值引用，两个示例如下：

```C++
template<typename T> 
void f(std::vector<T>&& param);   //param是右值引用
```
```C++
template<typename T> 
void f(const T&& param);          //param是右值引用
```
***



## 引用折叠——万能引用的原理
当引用的引用出现在允许的语境（即，万能引用时），该双重引用会被折叠成单个引用：我们有 `左值引用` 和 `右值引用`，所以就有四种可能的 **引用的引用组合**：左值-左值、左值-右值、右值-左值、右值-右值

但 C++ 规定了，如果任一引用为左值引用，则结果为左值引用。否则（即两个都为右值引用），结果为右值引用。

当我们对函数模板 `f` 实例化时，实际过程如下：
```C++
template<typename T>
void f(T && param);  // param是万能引用
```
```C++
MyClass a; // 自定义的MyClass类
f(a);  

// a 为左值，T 被推导为 MyClass& 
void f(MyClass& && param); // 调用f(a)时f的实例化
```

# 参考资料
- [C++的万能引用解析](https://www.cnblogs.com/wickedpriest/p/14994899.html)
- [C++11：搞清楚万能引用和右值引用](https://zhuanlan.zhihu.com/p/510193287)