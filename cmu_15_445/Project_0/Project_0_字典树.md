# Project 0
**项目目的**：在这个项目中，将实现一个支持的 `键-值` 存储的数据结构——字典树，这是一种高效的有序树数据结构，用于检索给定 `键` 的 `值`。为了简化解释，我们假设键都是变长的单词，但实际上它们可以包含任意类型字符。字典树中的每个节点存储一个单词的单个字符，并且节点中包含下一个可能出现的字符到其相应节点的索引。当到达键的结束时，还需要设置一个标志位来指示当前单词已到达末尾。

## 字典树中三个类的分析
字典树也称 `Trie树`， 在 `Trie` 类中 `TrieNode` 类会被作为指针来使用，同时 `TrieNodewithValue` 类会继承自 `TrieNode` 类，所以从 `TrieNode` 类开始分析并实现。

### TrieNode类
`TrieNode` 类用于抽象出 `Trie` 树中的每个节点。 
- **数据成员**：`TrieNode` 的数据成员包括 `key_char_` 用于存储一个字符，`is_end_` 是一个布尔值用于表示当前字符序列是否到达末尾， `children_` 存储了字符到其子节点地址的映射。
- **成员函数**：
    - `InsertChildNode` 和 `GetChildNode` 都返回一个指向 `unique_ptr<TrieNode>` 的指针，这样的好处是我们可以通过该指针来访问智能指针所管理的对象，而无序考虑 `unique_ptr` 的资源的所有权问题。
    - ❓ `TrieNode` 中移动构造函数的作用

### TrieNodeWithValue类
`TrieNodeWithValue` 类继承自 `TrieNode` 类，用于抽象出每个末尾节点。（❗**末尾节点：Trie树节点中 `is_end_ == true` 的节点**）
- **数据成员**：`key_char_` 代表的是字符序列的结束字符， `is_end_` 始终为 `True`，除此之外还有一个可以存储任意 `T` 类型的 `value_` 用于保存该字符序列（又称 `键`）所对应的 `值`。
- **成员函数**：❓暂时不知道成员函数的作用

### Trie类
`Trie` 类用于抽象出整个 *字典树* 。
- **数据成员**：*字典树* 中根节点的 `key_char_` 不应包含任何值，仅作为起始节点。
- **成员函数**：`Trie` 类支持对 *字典树* 的增( `Insert` )、删( `Remove` )、查( `GetValue` )操作。
    - 字典树中对一个单词的插入操作是逐字符进行的 `Insert`。当前字符不是末尾字符时，如果该字符不存在就直接插入即可。但当字符时末尾字符时，插入时有**三种**可能的情况。
    
    1. **该末尾字符不存在**，直接调用 `TrieNodeWithValue(char key_char, T value)` 创建新的末尾节点。

    2. **该末尾字符存在但相应节点不是末尾节点（is_end_ == false）**，需要调用 `TrieNodeWithValue(TrieNode &&trieNode, T value)` 将 `TrieNode` 类型节点转换为 `TrieNodeWithValue` 类型。

    3. **该末尾字符存在且相应节点是末尾节点（is_end_ == true）**，则需要立即返回 `false`，因为不允许重复的 `键`。   
***


## 前置知识：
### - [explicit关键字]() 
### - [智能指针](./前置知识/智能指针.md)
### - [移动语义](./前置知识/移动语义.md)
