#  顶层const和底层const
  
  
- **《C++Primer》** 2.4.3节中讲述了顶层const和底层const。
> 在对象拷贝时，顶层const可以忽略，而底层const在**拷贝**和**被拷贝**的对象之间必须保持一致。
  
下面列举了一些顶层const和底层const：
  
``` C++
const int *p = new int(10);     // 底层const
int *const pp = new int(20);   // 顶层const
const int a = 10;               // 顶层const
const int & ra = a;             // 底层const（引用本身具有顶层const属性）
```
  
再考虑如下代码:
  
```C++
const int a = 10;   // 顶层const
int *p = &a;        // ❌报错
```
  
虽然 `a` 此时是顶层const，但是对 `a` 取地址后，对于地址而言，修饰 `a` 的const就变为了底层const。
  
***
  
#  表达式类型 & 右值引用
  
  
- **《C++Primer》** 4.1.1节中讲述了**左值**与**右值**。
> 使用右值时，使用的是对象的值本身(它的内容)。
> 使用左值时，使用的是对象的身份(它在内存中的位置)。
  
##  操作符的返回值
  
  
不同操作符返回是右值还是左值是有区别的，现在考虑自增运算符（自减运算符同理），思考为什么会报错：
  
```c++
    int a = 10;
    int *p1 = &(a++);   // ❌报错
    int *p2 = &(++a);   // ✔
```
  
原因在于，前置++和后置++返回值的左值右值属性不同，**前置++返回自身引用（属于左值），后置++返回临时对象（属于右值）**：
  
```c++
struct T
{
    int i;
  
    // 前置++
    T & operator++()
    {
        ++(this->i);
        return *this;
    }
  
    // 后置++
    T operator++(int)
    {
        T temp = *this;     // 拷贝一个副本
        ++(*this);          // 调用前置++
        return temp;        // 返回副本
    }
};
```
##  左值引用与右值引用
  
  
1. 顾名思义，左值引用是对左值变量的引用，右值引用是对右值的引用。
2. 右值引用必须绑定到右值上。
3. 非`const`左值引用只能绑定到左值上，`const`左值引用既可以绑定左值也可以绑定右值。 
  
**注：`字符串字面值` 是左值(如下代码所示，可以取地址)，除此之外其他字面值均是右值。**
  
```C++
std::cout << &("Helloworld") << std::endl;  // 打印结果：0x404001
```
  
###  const左值引用
  
  
```c++
const int &a = 10; //✔正确
```
  
`const`左值引用既能绑定左值也能绑定右值，实际是通过如下方式实现：
  
```C++
int temp = 10;          // 编译器创建临时对象
const int &a = temp;    // cosnt左值引用实际绑定到临时对象上
```
###  右值引用
  
- **《C++Primer》** 13.6.1节中讲述了**右值引用**。
  
在只有复制语义时，拷贝构造函数和拷贝运算符函数的形参类型为**const左值引用**，而const左值引用根本不能区分出左值和右值。为了解决这个问题c++11引入了新的引用类型，称为 “右值引用”，用于识别右值。
  
> c++11中提出了`右值引用`，是为了和`左值引用`区分开来，`右值引用`限制了其只能接受右值（**能够接受①没有名称的临时对象以及②使用了std::move的对象**），可以识别出右值，因而利用这个特性从而实现**移动语义**。
  
  
  
> 右值引用有一个重要的属性，即它们只能绑定到即将被销毁的对象。
  右值引用本身是**左值**，不能把一个右值引用类型的变量绑定到右值引用上。
  
##  C++11的表达式类型（value category）
  
  
在 C++11 中，一共有 5 种 value：
- lvalue (Left-hand-side value)
- rvalue (Right-hand-side value)
- xvalue (eXpiring value)
- prvalue (Pure rvalue)
- glvalue (Generalized lvalue)
  
它们之间的关系如下图：
![C++11的表达式类型](../EffectiveModernC++.assets/Snipaste_2023-09-06_16-31-40.png )
  
> 为什么有这些表达式类型的产生？
  
答：在提出了右值引用后，表达式类型的划分由两个条件决定：
1. 是否有身份（地址）
2. 能否移动
  
每个C++表达式只属于三种基本值类别中的一种：**左值 (lvalue)、纯右值 (prvalue)、将亡值 (xvalue)。**
**C++没有既无“身份”也不能“被移动”的表达式**，两个条件排列组合后有三种结果，其中 **将亡值（xvalue）对应有“身份”且能“被移动”的表达式。**
  
C++11后，严格定义的左值和右值是由上述两个条件所决定的，在不考虑**移动**的情况下，可以简单依靠能否取地址区分左值右值，但是在移动语义情况下，能否取地址只能说明表达式当前是否有身份，表达式具体类型还需要考虑其是否可移动。
  
##  移动语义
  
  
移动语义使用的案例：
```C++
class MyClass 
{
public:
    MyClass(const char* str = "hello") // 构造
    : _str(str)
    {
        std::cout << "MyClass(const char*)" << std::endl;
    }
  
    MyClass(const MyClass & rhs) // 拷贝构造
    : _str(rhs._str)
    {
        std::cout << "拷贝构造" << std::endl;
    }
  
    MyClass(MyClass && rhs) noexcept // 移动构造
    : _str(std::move(rhs._str))
    {
        std::cout << "移动构造" << std::endl;
    }
private:
    std::string _str;
};
  
std::vector<MyClass> classes;
MyClass temp;
classes.push_back(temp);
classes.push_back(std::move(temp));
```
  
容器vector支持动态扩容，在扩容后不仅要将新元素添加进来，还需要将老元素挪到新的内存空间中。但是如果老元素的挪动采用拷贝的话效率太低，为了在老元素的挪动过程使用移动语义提高效率，就需要在移动构造函数添加上noexcept说明符，noexcept说明符作用是告诉编译器此操作**不会产生异常**（即“被拷贝对象的原始数据是不会丢失的”），即人为实现了“强异常保证（strong exception guarantee）”。编译器只有确保强异常保证，才会使用移动来挪动老元素。
  
**"强异常保证（strong exception guarantee）"**：所谓强异常保证，即当我们调用一个函数时，如果发生了异常，那么应用程序的状态能够回滚到函数调用之前
  
##  std::move
  
  
> 被移动对象的状态是什么？
  
当一个对象被移动之后，该对象仍然是有效的，你可以继续使用它，最终它会被销毁，执行析构函数。C++明确了所有标准库中的对象，当被移动之后，会处于一个"有效但未定义的状态（valid but unspecified state）"。C++中也并没有强制的规定限制被移动对象必须处于什么状态。
  